# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'HW1.ui'
#
# Created by: PyQt5 UI code generator 5.15.7
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets

import os
import cv2
import numpy as np
import glob
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
from natsort import natsorted

class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(800, 600)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        # 2. Augmented Reality
        self.groupBox_AugmentedReality = QtWidgets.QGroupBox(self.centralwidget)
        self.groupBox_AugmentedReality.setGeometry(QtCore.QRect(380, 60, 161, 351))
        self.groupBox_AugmentedReality.setObjectName("groupBox_AugmentedReality")
        self.B2_1_Show_Words_on_Board = QtWidgets.QPushButton(self.groupBox_AugmentedReality)
        self.B2_1_Show_Words_on_Board.setGeometry(QtCore.QRect(10, 130, 140, 20))
        self.B2_1_Show_Words_on_Board.setObjectName("B2_1_Show_Words_on_Board")
        self.B2_2_Show_Words_Vertically = QtWidgets.QPushButton(self.groupBox_AugmentedReality)
        self.B2_2_Show_Words_Vertically.setGeometry(QtCore.QRect(10, 170, 140, 20))
        self.B2_2_Show_Words_Vertically.setObjectName("B2_2_Show_Words_Vertically")
        self.textEdit = QtWidgets.QTextEdit(self.centralwidget)
        self.textEdit.setGeometry(QtCore.QRect(400, 150, 100, 25))
        self.textEdit.setObjectName("textEdit")
        # 3. Stereo Disparity Map
        self.groupBox_StereoDisparityMap = QtWidgets.QGroupBox(self.centralwidget)
        self.groupBox_StereoDisparityMap.setGeometry(QtCore.QRect(550, 60, 161, 351))
        self.groupBox_StereoDisparityMap.setObjectName("groupBox_StereoDisparityMap")
        self.B3_1_Show_Disparity_Map = QtWidgets.QPushButton(self.groupBox_StereoDisparityMap)
        self.B3_1_Show_Disparity_Map.setGeometry(QtCore.QRect(10, 140, 140, 20))
        self.B3_1_Show_Disparity_Map.setObjectName("B3_1_Show_Disparity_Map")
        self.B3_2_Checking_the_Disparity_Value = QtWidgets.QPushButton(self.groupBox_StereoDisparityMap)
        self.B3_2_Checking_the_Disparity_Value.setGeometry(QtCore.QRect(10, 180, 140, 20))
        self.B3_2_Checking_the_Disparity_Value.setObjectName("B3_2_Checking_the_Disparity")
        # 1. Calibration
        self.groupBox_Calibration = QtWidgets.QGroupBox(self.centralwidget)
        self.groupBox_Calibration.setGeometry(QtCore.QRect(200, 60, 161, 351))
        self.groupBox_Calibration.setObjectName("groupBox_Calibration")
        self.B1_1_Find_Corners = QtWidgets.QPushButton(self.groupBox_Calibration)
        self.B1_1_Find_Corners.setGeometry(QtCore.QRect(20, 30, 110, 20))
        self.B1_1_Find_Corners.setObjectName("B1_1_Find_Corners")
        self.B1_2_Find_Intrinsic = QtWidgets.QPushButton(self.groupBox_Calibration)
        self.B1_2_Find_Intrinsic.setGeometry(QtCore.QRect(20, 70, 110, 20))
        self.B1_2_Find_Intrinsic.setObjectName("B1_2_Find_Intrinsic")
        self.B1_4_Find_Distortion = QtWidgets.QPushButton(self.groupBox_Calibration)
        self.B1_4_Find_Distortion.setGeometry(QtCore.QRect(20, 210, 110, 20))
        self.B1_4_Find_Distortion.setObjectName("B1_4_Find_Distortion")
        self.B1_5_Show_Result = QtWidgets.QPushButton(self.groupBox_Calibration)
        self.B1_5_Show_Result.setGeometry(QtCore.QRect(20, 260, 110, 20))
        self.B1_5_Show_Result.setObjectName("B1_5_Show_Result")
        self.groupBox_5 = QtWidgets.QGroupBox(self.groupBox_Calibration)
        self.groupBox_5.setGeometry(QtCore.QRect(10, 110, 141, 91))
        self.groupBox_5.setObjectName("groupBox_5")
        self.B1_3_Find_Extrinsic = QtWidgets.QPushButton(self.groupBox_5)
        self.B1_3_Find_Extrinsic.setGeometry(QtCore.QRect(10, 50, 110, 20))
        self.B1_3_Find_Extrinsic.setObjectName("B1_3_Find_Extrinsic")
        self.comboBox = QtWidgets.QComboBox(self.groupBox_5)
        self.comboBox.setGeometry(QtCore.QRect(10, 20, 69, 22))
        self.comboBox.setObjectName("comboBox")
        self.groupBox_Loading = QtWidgets.QGroupBox(self.centralwidget)
        self.groupBox_Loading.setGeometry(QtCore.QRect(30, 60, 161, 351))
        self.groupBox_Loading.setObjectName("groupBox_Loading")
        #Load Image
        self.BL_Img_Folder = QtWidgets.QPushButton(self.groupBox_Loading)
        self.BL_Img_Folder.setGeometry(QtCore.QRect(30, 60, 90, 20))
        self.BL_Img_Folder.setObjectName("BL_Img_Folder")
        self.BL_Img_L = QtWidgets.QPushButton(self.groupBox_Loading)
        self.BL_Img_L.setGeometry(QtCore.QRect(30, 120, 90, 20))
        self.BL_Img_L.setObjectName("BL_Img_L")
        self.BL_Img_R = QtWidgets.QPushButton(self.groupBox_Loading)
        self.BL_Img_R.setGeometry(QtCore.QRect(30, 180, 90, 20))
        self.BL_Img_R.setObjectName("BL_Img_R")
        
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 800, 21))
        self.menubar.setObjectName("menubar")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)

        self.retranslateUi(MainWindow)
        self.initial_define()
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

        self.folder_path = ""
        self.img_L = ""
        self.img_R = ""

    def initial_define(self): 
        self.BL_Img_Folder.clicked.connect(self.load_img_folder)
        self.BL_Img_L.clicked.connect(self.load_img_L)
        self.BL_Img_R.clicked.connect(self.load_img_R)
        self.B1_1_Find_Corners.clicked.connect(self.find_corners)
        self.B1_2_Find_Intrinsic.clicked.connect(self.find_intrinsic)
        self.B1_3_Find_Extrinsic.clicked.connect(self.find_extrinsic)
        self.B1_4_Find_Distortion.clicked.connect(self.find_distortion)
        self.B1_5_Show_Result.clicked.connect(self.show_result)
        self.B2_1_Show_Words_on_Board.clicked.connect(self.show_words_on_board)
        self.B2_2_Show_Words_Vertically.clicked.connect(self.show_words_vertically)
        self.B3_1_Show_Disparity_Map.clicked.connect(self.show_disparity_map)
        self.B3_2_Checking_the_Disparity_Value.clicked.connect(self.checking_the_disparity_value)

    def load_img_folder(self):
        self.folder_path = QtWidgets.QFileDialog.getExistingDirectory(self.BL_Img_Folder, "Open folder", "./")
        Image_glob= os.path.join(self.folder_path,'*.bmp')
        Image_name_list = []
        Image_name_list.extend(glob.glob(Image_glob))
        Image_name_list = natsorted(Image_name_list)
        id = []
        for i in range(len(Image_name_list)):
            id.append(str(i+1)+'.bmp')
        self.comboBox.addItems(id)

    def calibrate(self):
        criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 30, 0.001)
        # criteria = （type達成任一條件即停止,max_iter迭代次數,epsilon精準度）
        w = 11
        h = 8
        objp = np.zeros((w*h,3), np.float32)
        objp[:,:2] = np.mgrid[0:w,0:h].T.reshape(-1,2)
        #存儲棋盤格角點的世界坐標和圖像坐標對
        objpoints = [] #在世界坐標系中的三維點
        imgpoints = [] #在圖像平面的二維點
        # Image_glob = os.path.join('C:\CvDL_HW\HW1_1\Dataset_CvDl_Hw1\Q1_Image','*.bmp')
        Image_glob= os.path.join(self.folder_path,'*.bmp')
        Image_name_list = []
        Image_name_list.extend(glob.glob(Image_glob))
        Image_name_list = natsorted(Image_name_list)
        print("............")
        for Image_i in Image_name_list:
            image = mpimg.imread(Image_i)
            gray = cv2.cvtColor(image,cv2.COLOR_BGR2GRAY)
            ret, corners = cv2.findChessboardCorners(gray, (w,h),None)
            if ret == True:
                cv2.cornerSubPix(gray,corners,(11,11),(-1,-1),criteria)
                objpoints.append(objp)
                imgpoints.append(corners)
                #將角點在圖像上顯示
                cv2.drawChessboardCorners(image, (w,h), corners,ret)
                image=cv2.resize(image,(640,480))
                #cv2.imshow('findCorners'+Image_i,image)
                cv2.waitKey(1000)
        cv2.destroyAllWindows()  
        ret, mtx, dist, rvecs, tvecs = cv2.calibrateCamera(objpoints, imgpoints, gray.shape[::-1],None,None)
        out = dict()
        out['Image_i'] = Image_i
        out['image'] = image
        out['mtx'] = mtx
        out['dist'] = dist
        out['rvecs'] = rvecs
        out['tvecs'] = tvecs
        out['objpoints']=objpoints
        out['imgpoints']=imgpoints
        out['Image_name_list']=Image_name_list
        return out

    
    def find_corners(self):
        criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 30, 0.001)
        w = 11
        h = 8
        objp = np.zeros((w*h,3), np.float32)
        objp[:,:2] = np.mgrid[0:w,0:h].T.reshape(-1,2)
        objpoints = [] #在世界坐標系中的三維點
        imgpoints = [] #在圖像平面的二維點
        # Image_glob = os.path.join('C:\CvDL_HW\HW1_1\Dataset_CvDl_Hw1\Q1_Image','*.bmp')
        Image_glob= os.path.join(self.folder_path,'*.bmp')
        Image_name_list = []
        Image_name_list.extend(glob.glob(Image_glob))
        Image_name_list = natsorted(Image_name_list)
        for Image_i in Image_name_list:
            image = mpimg.imread(Image_i)
            gray = cv2.cvtColor(image,cv2.COLOR_BGR2GRAY)
            ret, corners = cv2.findChessboardCorners(gray, (w,h),None)
            if ret == True:
                cv2.cornerSubPix(gray,corners,(11,11),(-1,-1),criteria)
                objpoints.append(objp)
                imgpoints.append(corners)
                cv2.drawChessboardCorners(image, (w,h), corners,ret)
                image=cv2.resize(image,(640,640))
                cv2.imshow('findCorners'+Image_i,image)
                cv2.waitKey(1000)
        cv2.destroyAllWindows() 

    def find_intrinsic(self):
        print("Finding Intrinsic Matrix...")
        out=self.calibrate()
        print("Intrinsic Matrix=\n",out['mtx']) #內參矩陣

    def find_extrinsic(self):
        criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 30, 0.001)
        w = 11
        h = 8
        objp = np.zeros((w*h,3), np.float32)
        objp[:,:2] = np.mgrid[0:w,0:h].T.reshape(-1,2)
        objpoints = [] #在世界坐標系中的三維點
        imgpoints = [] #在圖像平面的二維點
        # Image_glob = os.path.join('C:\CvDL_HW\HW1_1\Dataset_CvDl_Hw1\Q1_Image','*.bmp')
        Image_glob= os.path.join(self.folder_path,'*.bmp')
        Image_name_list = []
        Image_name_list.extend(glob.glob(Image_glob))
        Image_name_list = natsorted(Image_name_list)
        #for Image_i in Image_name_list:
        id = self.comboBox.currentIndex()
        Image_i = Image_name_list[id]
        image = mpimg.imread(Image_i)
        gray = cv2.cvtColor(image,cv2.COLOR_BGR2GRAY)
        ret, corners = cv2.findChessboardCorners(gray, (w,h),None)
        if ret == True:
            cv2.cornerSubPix(gray,corners,(11,11),(-1,-1),criteria)
            objpoints.append(objp)
            imgpoints.append(corners)
        _, _, _, rvecs, tvecs = cv2.calibrateCamera(objpoints, imgpoints, gray.shape[::-1],None,None)
        #for i in range(len(rvecs)):
        rve,_=cv2.Rodrigues(rvecs[0])
        print(f"Extrinsic Matrix{id+1}: \n",np.hstack((rve,tvecs[0])))


    def find_distortion(self):
        print("Finding distortion...")
        out=self.calibrate()
        print("Distortion Matrix=\n", out['dist'])  #畸變係數   - k1,k2,p1,p2,k3

    def show_result(self):
        print("Showing result...")
        out=self.calibrate()
        Image_glob= os.path.join(self.folder_path,'*.bmp')
        Image_name_list = []
        Image_name_list.extend(glob.glob(Image_glob))
        Image_name_list = natsorted(Image_name_list)
        for Image_i in Image_name_list:
            image = mpimg.imread(Image_i)
            h,  w = image.shape[:2]
            newcameramtx, roi=cv2.getOptimalNewCameraMatrix(out['mtx'],out['dist'],(w,h),1,(w,h))
            dst = cv2.undistort(image, out['mtx'], out['dist'], None, newcameramtx)
            x,y,w,h = roi
            dst = dst[y:y+h, x:x+w]
            dst=cv2.resize(dst,(640,640))
            cv2.putText(dst,'undistort',(10,30),cv2.FONT_HERSHEY_SIMPLEX,1,(0,0,255),2)
            image = cv2.resize(image,(640,640))
            cv2.putText(image,'distort',(10,30),cv2.FONT_HERSHEY_SIMPLEX,1,(0,0,255),2)
            horizontal = np.hstack((image, dst))
            cv2.imshow('undistort',horizontal)
            cv2.waitKey(1000)
        cv2.destroyAllWindows()     

    def show_words_on_board(self):
        def camer(Image_name_list):
            for fname in Image_name_list:
                image = mpimg.imread(fname)
                gray = cv2.cvtColor(image,cv2.COLOR_BGR2GRAY)
                ret, corners = cv2.findChessboardCorners(gray, (w,h),None)
                if ret == True:
                    cv2.cornerSubPix(gray,corners,(11,11),(-1,-1),criteria)
                    objpoints.append(objp)
                    imgpoints.append(corners)
                    #將角點在圖像上顯示
                    cv2.drawChessboardCorners(image, (w,h), corners,ret)
                    image=cv2.resize(image,(640,640))
            _, mtx, dist, _, _ = cv2.calibrateCamera(objpoints, imgpoints, gray.shape[::-1],None,None)
            # _, mtx, dist, _, _ = cv2.calibrateCamera(objp, corners, gray.shape[::-1],None,None)
            out=dict() 
            out['mtx']=mtx
            print('mtx=',mtx)
            out['dist']=dist
            return out

        def draw(img, corners2, imgpts):
            imgpts = np.int32(imgpts).reshape(-1,2)
            for i in range(0,len(imgpts),2):
                img = cv2.drawContours(img, [imgpts[i:i+2]],-1,(0,0,255),3)
                # i=i+2
            return img

        Text = self.textEdit.toPlainText()
        #str2char
        char_list = []  
        if len(Text) <0:
            return
        elif len(Text) <=6:
            for i in range(len(Text)):
                if Text[i].isupper():
                    char_list.append(Text[i])
        else :
            for i in range(6):
                if Text[i].isupper():
                    char_list.append(Text[i])

        criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 30, 0.001)
        w=11
        h=8
        objp = np.zeros((w*h,3), np.float32)
        objp[:,:2] = np.mgrid[0:w,0:h].T.reshape(-1,2)               
        fs = cv2.FileStorage('C:\CvDL_HW\HW1_1\Dataset_CvDl_Hw1\Q2_Image\Q2_lib/alphabet_lib_onboard.txt', cv2.FILE_STORAGE_READ)

        objpoints = [] #在世界坐標系中的三維點
        imgpoints = [] #在圖像平面的二維點

        Image_glob= os.path.join(self.folder_path,'*.bmp')
        Image_name_list = []
        Image_name_list.extend(glob.glob(Image_glob))
        Image_name_list = natsorted(Image_name_list)
        print('show_words_on_board')

        for fname in Image_name_list:
            out=camer(Image_name_list)
            img = mpimg.imread(fname)
            gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)
            ret, corners2 = cv2.findChessboardCorners(gray, (w,h),None)
            print(corners2[0])
            if ret == True:
                corners2 = cv2.cornerSubPix(gray,corners2,(11,11),(-1,-1),criteria)
                for i in range(len(char_list)):
                    ret,rvecs, tvecs = cv2.solvePnP(objp, corners2, out['mtx'], out['dist'])
                    points = list()
                    points.append(corners2[62])
                    points.append(corners2[59])
                    points.append(corners2[56])
                    points.append(corners2[29])
                    points.append(corners2[26])
                    points.append(corners2[23])
                    Node = char_list[i]
                    axis= np.float32(fs.getNode(Node).mat())
                    axis = axis.reshape([-1,3])
                    imgpts, jac = cv2.projectPoints(axis, rvecs, tvecs, out['mtx'], out['dist'])

                    xy = points[i] - corners2[0]
                    # draw point
                    imgpts = imgpts + xy
                    img = draw(img,points,imgpts)
                cv2.imshow('img',cv2.resize(img,(640,640)))
                cv2.waitKey(1000)
        cv2.destroyAllWindows()


    def show_words_vertically(self):
        def camer(Image_name_list):
            for fname in Image_name_list:
                image = mpimg.imread(fname)
                gray = cv2.cvtColor(image,cv2.COLOR_BGR2GRAY)
                ret, corners = cv2.findChessboardCorners(gray, (w,h),None)
                if ret == True:
                    cv2.cornerSubPix(gray,corners,(11,11),(-1,-1),criteria)
                    objpoints.append(objp)
                    imgpoints.append(corners)
                    #將角點在圖像上顯示
                    cv2.drawChessboardCorners(image, (w,h), corners,ret)
                    image=cv2.resize(image,(640,640))
            _, mtx, dist, _, _ = cv2.calibrateCamera(objpoints, imgpoints, gray.shape[::-1],None,None)
            out=dict() 
            out['mtx']=mtx
            print('mtx=',mtx)
            out['dist']=dist
            return out

        def draw(img, corners2, imgpts):
            imgpts = np.int32(imgpts).reshape(-1,2)
            for i in range(0,len(imgpts),2):
                img = cv2.drawContours(img, [imgpts[i:i+2]],-1,(0,0,255),3)
                # i=i+2
            return img

        Text = self.textEdit.toPlainText()
        #str2char
        char_list = []
        if len(Text) <0:
            return
        elif len(Text) <=6:
            for i in range(len(Text)):
                if Text[i].isupper():
                    char_list.append(Text[i])
        else :
            for i in range(6):
                if Text[i].isupper():
                    char_list.append(Text[i])

        criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 30, 0.001)
        w=11
        h=8
        objp = np.zeros((w*h,3), np.float32)
        objp[:,:2] = np.mgrid[0:w,0:h].T.reshape(-1,2)               
        fs = cv2.FileStorage('C:\CvDL_HW\HW1_1\Dataset_CvDl_Hw1\Q2_Image\Q2_lib/alphabet_lib_vertical.txt', cv2.FILE_STORAGE_READ)

        objpoints = [] #在世界坐標系中的三維點
        imgpoints = [] #在圖像平面的二維點

        Image_glob= os.path.join(self.folder_path,'*.bmp')
        Image_name_list = []
        Image_name_list.extend(glob.glob(Image_glob))
        Image_name_list = natsorted(Image_name_list)
        print('show_words_on_board')

        for fname in Image_name_list:
            out=camer(Image_name_list)
            img = mpimg.imread(fname)
            gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)
            ret, corners2 = cv2.findChessboardCorners(gray, (w,h),None)
            print(corners2[0])
            if ret == True:
                corners2 = cv2.cornerSubPix(gray,corners2,(11,11),(-1,-1),criteria)
                for i in range(len(char_list)):
                    ret,rvecs, tvecs = cv2.solvePnP(objp, corners2, out['mtx'], out['dist'])
                    points = list()
                    points.append(corners2[62])
                    points.append(corners2[59])
                    points.append(corners2[56])
                    points.append(corners2[29])
                    points.append(corners2[26])
                    points.append(corners2[23])
                    Node = char_list[i]
                    axis= np.float32(fs.getNode(Node).mat())
                    axis = axis.reshape([-1,3])
                    imgpts, jac = cv2.projectPoints(axis, rvecs, tvecs, out['mtx'], out['dist'])

                    xy = points[i] - corners2[0]
                    # draw point
                    imgpts = imgpts + xy
                    img = draw(img,points,imgpts)
                cv2.imshow('img',cv2.resize(img,(640,640)))
                cv2.waitKey(1000)
        cv2.destroyAllWindows()

    def load_img_L(self):
        self.img_L, _ = QtWidgets.QFileDialog.getOpenFileName(self.BL_Img_L, '開啟檔案', os.getcwd(), 'All Files (*);;JPEG Files (*.jpg/*.bmp/*.png)')

    def load_img_R(self):
        self.img_R, _ = QtWidgets.QFileDialog.getOpenFileName(self.BL_Img_R, '開啟檔案', os.getcwd(), 'All Files (*);;JPEG Files (*.jpg/*.bmp/*.png)')

    def show_disparity_map(self):
        imgL = cv2.imread(self.img_L,0)
        imgR = cv2.imread(self.img_R,0)
        stereo = cv2.StereoBM_create(numDisparities=256, blockSize=25)
        disparity = stereo.compute(imgL,imgR)
        imgLL = cv2.imread(self.img_L)
        imgLL=cv2.resize(imgLL,(640,480))
        imgRR = cv2.imread(self.img_R)
        imgRR=cv2.resize(imgRR,(640,480))
        cv2.imshow('left image',imgLL)
        cv2.imshow('right image',imgRR)
        plt.imshow(disparity,'gray')
        plt.show()

    def disparity_data(self):
        self.imageL = cv2.imread(self.img_L)
        self.imageR = cv2.imread(self.img_R)
        # rgb2gray
        grayL = cv2.cvtColor(self.imageL, cv2.COLOR_BGR2GRAY)
        grayR = cv2.cvtColor(self.imageR, cv2.COLOR_BGR2GRAY)
        stereo = cv2.StereoBM_create(numDisparities=256, blockSize=25)
        self.disparity = stereo.compute(grayL, grayR)
        self.disp_norm = cv2.normalize(
            self.disparity,
            self.disparity,
            alpha=0,
            beta=255,
            norm_type=cv2.NORM_MINMAX,
            dtype=cv2.CV_8U,
        )
    def draw_match(self, event, x, y, flags, param):
        if event == cv2.EVENT_LBUTTONDOWN:
                imgL = self.imageL.copy()
                imgR = self.imageR.copy()
                horizontal = np.hstack((imgL, imgR))
                horizontal = cv2.resize(horizontal, (1398, 476)) #image=(2724,1848)
                x = x * 4
                y = y * 4
                if x > self.disparity.shape[1]:
                    cv2.imshow(self.win_name, horizontal)
                    return
                disp = int(self.disparity[y][x] / 16)
                if disp <= 0:
                    cv2.imshow(self.win_name, horizontal)
                    return

                print(x, y, disp)

                point = (x - disp, y)
                imgR = cv2.circle(imgR, point, 20, (0, 0, 255), -1)
                horizontal = np.hstack((imgL, imgR))
                horizontal = cv2.resize(horizontal, (1398, 476)) #image=(2724,1848)
                cv2.imshow(self.win_name, horizontal)
                #cv2.imshow(horizontal)


    def checking_the_disparity_value(self):
        self.disparity_data()
        horizontal = np.hstack((self.imageL, self.imageR))
        horizontal = cv2.resize(horizontal, (1398, 476))
        self.win_name='Checking the Disparity Value'
        cv2.namedWindow(self.win_name)
        cv2.setMouseCallback(self.win_name, self.draw_match)
        cv2.imshow(self.win_name, horizontal)


    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.groupBox_AugmentedReality.setTitle(_translate("MainWindow", "2. Augmented Reality"))
        self.B2_1_Show_Words_on_Board.setText(_translate("MainWindow", "2.1 Show Words on Board"))
        self.B2_2_Show_Words_Vertically.setText(_translate("MainWindow", "2.2 Show Words Vertically"))
        # self.setText(_translate("MainWindow", ""))   #textedit
        self.groupBox_StereoDisparityMap.setTitle(_translate("MainWindow", "3. Stereo Disparity Map"))
        self.B3_1_Show_Disparity_Map.setText(_translate("MainWindow", "3.1 Show Disparity Map"))
        self.B3_2_Checking_the_Disparity_Value.setText(_translate("MainWindow", "3.2 Checking_the_Disparity"))
        self.groupBox_Calibration.setTitle(_translate("MainWindow", "1. Calibration"))
        self.B1_1_Find_Corners.setText(_translate("MainWindow", "1.1 Find Corners"))
        self.B1_2_Find_Intrinsic.setText(_translate("MainWindow", "1.2 Find Intrinsic"))
        self.B1_4_Find_Distortion.setText(_translate("MainWindow", "1.4 Find Distortion"))
        self.B1_5_Show_Result.setText(_translate("MainWindow", "1.5 Show Result"))
        self.groupBox_5.setTitle(_translate("MainWindow", "1.3 Find Extrinsic"))
        self.B1_3_Find_Extrinsic.setText(_translate("MainWindow", "1.3 Find Extrinsic"))
        self.groupBox_Loading.setTitle(_translate("MainWindow", "Load Image"))
        self.BL_Img_Folder.setText(_translate("MainWindow", "Load Folder"))
        self.BL_Img_L.setText(_translate("MainWindow", "Load Image_L"))
        self.BL_Img_R.setText(_translate("MainWindow", "Load Image_R"))


if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())

    
